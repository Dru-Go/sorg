+++
image_alt = "TODO"
image_orientation = "portrait"
# image_url = "/photographs/nanoglyphs/026-ids/salesforce-park@2x.jpg"
image_url = "/photographs/nanoglyphs/026-ids/pacifica@2x.jpg"
published_at = 2021-06-21T04:31:56Z
title = "Sequence Versus UUID as Primary Key: The Perennial Debate"
+++

A few weeks ago, Cybertec put together a great piece on the use of [UUIDs vs. `bigserial` vs `IDENTITY`](https://www.cybertec-postgresql.com/en/uuid-serial-or-identity-columns-for-postgresql-auto-generated-primary-keys/) as primary keys in a Postgres database.

The release was quite timely for me, as I'd been considering it very recently in the context of our own application, and coincidentally it'd also been challenged via GitHub issue on the Heroku HTTP API design guide, in which when it was written years ago, we suggested [always using UUIDs](https://github.com/brandur/heroku-http-api-design#provide-resource-uuids).

These days, I'm far less certain which one to suggest, and as you'll see by the end of this, the answer is probably a more subtle combination of the best aspects of both.

### UUID graces (#uuid-graces)

```
CREATE TABLE has_uuid_pkey (
   id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
   ...
);
```

UUIDs as primary key have a few advantages. And when we talk about UUIDs in this context, we're usually talking about _V4_ UUIDs, which are the kind that are completely random.

* The fact that they're random means that they don't rely on a single sequence to be generated. Multiple actors can generate IDs and store them independently from each other. There's no single bottleneck that could one day be a problem for scaling or performance.

* They are opaque from a user-facing perspective. With sequences, users may be able to make inferences about how much data is being generated by watching them increment over time. Malicious users might take advantage of them to try attacks based on ID iteration or collision.

* They occasionally reduce operational accidents. Especially in smaller programs it's common to occasionally drop into `psql` and fix something manually in the database, and while doing so, use an integer ID on the wrong table. And because integer sequences start from 1 and share a range everywhere, that might mean that you select or update the wrong data. This has occasionally happened to me, although never caused any catastrophic problems. UUIDs have so much entropy that there's practically zero chance of conflict. If you update or delete on the wrong table with an ID that's a UUID, nothing will happen.

But these upsides seem to be more than outweighed by some very serious performance considerations:

* Because UUIDs are random, new entries might be inserted anywhere in an index (like a B-tree). That means having to bring more pages into memory and more cache misses. With a `bigserial` on the other hand, because all new numbers are in close succession, the index is almost always operating on just a handful of pages at the end.

* Relatedly, with UUIDs writing to pages all over the place, those modified pages all need to be sent the write-ahead log (WAL) for replication. This results in an amplification effect where more WAL needs to be written, which means more data to replicate across network links, and a greater likelihood of production problems.

At smaller scale, neither of these is likely to cause much trouble. Postgres is very efficient, and working with UUIDs will mostly be fine. However, in a hot system doing a lot of inserts, the effect will be noticeable. Here are a few charts from 2nd Quadrant showing the lopsidedness of using random UUIDs versus more deterministic techniques. With a large data set, notice how poorly randomness performs on transaction throughput and how much much additional WAL it produces:

<img src="/photographs/nanoglyphs/026-ids/uuid-tps@2x.png" alt="Transactions per second comparison" class="img_constrained" loading="lazy">

<img src="/photographs/nanoglyphs/026-ids/uuid-wal-medium-normalized@2x.png" alt="WAL size comparison" class="img_constrained" loading="lazy">

_(These from [2nd Quadrant](https://www.2ndquadrant.com/en/blog/sequential-uuid-generators/). In the first graph, see how the blue bars (random UUIDs) for medium/large data sets are so much smaller than the other strategies. In the second, see how random produces orders of magnitude more WAL volume. The comparisons are a little more complex than UUID vs. `bigserial` -- more below.)_

### The benefits of `bigserial` (#benefits-bigserial)

```
CREATE TABLE uses_serial (
   id bigserial PRIMARY KEY,
   ...
);
```

Now onto the advantages of "just" using a `bigserial`.

(Side note: I'm going out of my way here to talk about `bigserial`, which is a 64-bit integer, rather than just `serial`, which is 32. Simplifying only an itsy bitsy tiny bit, in today's world there is _never_ a good reason to use a 32-bit sequence rather than a 64-bit one now that 64-bit architecture is so ubiquitous. There's a very real possibility of overflowing a 32-bit sequence, while with a 64-bit sequence there's not. Always use `bigserial`.)

`bigserial` advantages:

* Integer sequences occupy only 64 bits while UUIDs are 128, so there's a slight storage saving. There's more entropy in a UUID, but 64 bits is plenty big enough to never run out of IDs.

* Integers are more human friendly. A human can easily notice the difference between a 3-digit number, 4-digit number, or 8-digit number, or even the difference between two 8-digit numbers because they can fit inside of our fleshy grey matter. Conversely, a human remembering a long, dense string-formatted UUID is very unlikely.

But by far the largest benefit of a `bigserial` is that it doesn't have the downsides of UUIDs. New insertions will occur on relatively few pages in an index, allowing more transaction throughput, and creating minimal WAL volume.

### Honorary mention: `IDENTITY` (#identity)

One subject touched upon in Cybertec's article that was a TIL for me was the `IDENTITY` keyword:

```
CREATE TABLE uses_identity (
   id bigint GENERATED ALWAYS AS IDENTITY
             PRIMARY KEY,
   ...
);
```

`IDENTITY` has identical performance characteristics to a `bigserial`, but it's more standard across SQL dialects, and more importantly, it'll error if a row is inserted with an arbitrary value -- all insertions must get a value from the default sequence. Although it'll make almost no difference for most day-to-day uses, it's yet another bug-proofing feature that RDMSes are so good at providing.

## UUIDs with sequential tendencies (#sequential-tendencies)

It turns out that it's possible to use UUIDs with very few downsides by introducing some determinism into the generator algorithm. 2nd Quadrant [writes about sequential UUIDs](https://www.2ndquadrant.com/en/blog/sequential-uuid-generators/), using the [sequential-uuids extension](https://github.com/tvondra/sequential-uuids) to introduce two new UUID generator function:

* `uuid_sequence_nextval(sequence, block_size, block_count)`
* `uuid_time_nextval(interval_length, block_count)`

Both operate under the same general idea: reserve some amount of fixed space at the beginning of a UUID for _non_-random data, and leave the rest of it for randomness. `uuid_sequence_nextval` uses a sequence to produce the non-random portion while `uuid_time_nextval` uses the current timestamp. Both are highly configurable, but a decent default for `uuid_time_nextval` would be to use a block with 64k values, meaning that we'd reserve 16 bits at the beginning of a UUID for the sequence, with the other 112 bits still random:

```
    82cc              495e-9d2a-4b18-af79-73de1cb3209e
|----------|    |------------------------------------------|
  sequence                         random
  16 bits                         112 bits
```

64k values isn't enough to continue incrementing perpetually, so the generator is designed to recycle back to the beginning of the sequence regularly:

```
prefix := (nextval('s') / block_size) % block_count
```

So if you visualize a B-tree as a single-dimensional continuum, you can think of the UUID generator as a cursor slowly moving from one end to the other, busily producing values along the way. As it brushes up against the far end by exhausting its prefix space it jumps back to the other side and starts over again.

See 2nd Quadrant's article on the subject for more detail, but the short version is that in practice this solves the performance problems with UUIDs -- new inserts are mapping to the same set of new pages, meaning fewer pages in memory and fewer cache misses, leading to good transaction throughput and less WAL amplification.

### Honorary mention: ULIDs and Stripe IDs (#ulids)

An interesting attempt to generalize this idea are [ULIDs](https://github.com/ulid/spec) ("Universally Unique Lexicographically Sortable Identifier"). They're a 128-bit type compatible with UUID (meaning you can store them into the `uuid` type in Postgres or in various programming languages) that reserves the first 48 bits for a timestamp and the rest for randomness:

```
    01AN4Z07BY             79KA1307SR9X4MV3
|----------------|    |------------------------|
       time                   randomness
      48bits                    80bits
```

The timestamp is written as time since the Unix epoch in milliseconds, and 48 bits is enough runway to not overflow until 10,889 AD.

ULIDs differ from the Postgres UUID generators above in that the frontloaded bits are always incrementing and never recycle. This has the nice advantage of keeping all ULIDs created anywhere nicely sortable compared to each other. It has the downsides of being more prone to collision and predictability because there are fewer random bits, and could produce a lopsided index if many values are inserted then subsequently deleted because prefixes will never be reused.

A nice thing about ULIDs is that the algorithm is implemented in every programming language under the sun including [native SQL for Postgres](https://github.com/geckoboard/pgulid), only requiring access to the `pgcrypto` extension. The UUIDs generators above are their own Postgres extension, which is a problem when it comes to hosted Postgres.

Fun fact, Stripe IDs are more or less a ULID:

```
ch_1Iyqf42eZvKYlo2C4MIyA80e
```

They don't share anything with the ULID spec, but are an example of [multiple discovery](https://en.wikipedia.org/wiki/Multiple_discovery) of a fairly intuitive idea. Some number of those bits at the beginning are a timestamp while the rest are random entropy.

### ID prefixes (#id-prefixes)

Another Stripe concept that's not a bad idea is attaching an ID prefix like `ch_`. This makes it very easy for a human to match an ID to a resource type, and also enables the development of some useful tools. For example, at Stripe we had an internal admin lookup panel where you could plug in any ID and it would instantly take you to a representation of that object (or even just paste one into your URL bar like `http://go/object/<id>`). Without a prefix this would require a brute force lookup on every table or maintaining a single master lookup table, but with a prefix, it just involves translating prefix to resource type and doing a lookup on the corresponding table. Very fast, very simple.

A small problem with ID prefixes is that the space efficiency of storing a `bigserial` (exactly 64 bits) or `uuid`/ulid (exactly 128 bits) is pretty nice. Not only are they very compact, but database optimizations like [SortSupport](/sortsupport) make them faster to sort and build indexes on as well. Pushing a string prefix onto the front would seem to compromise that by forcing the ID to be stored as `varchar`/`text`, but a pretty simple workaround to get the upside of both is to keep IDs stored as compact binary and add prefixes at the time they're being rendered publicly:

``` ruby
def render_id
  'ch_' + uuid.string()
end
```

Similarly, when interpreting a lookup for such an ID, parse off the prefix before querying the DB.

(And by the way, with this one small tweak and you'll be significantly one-upping Stripe in a technical sense.)

## Showdown (#showdown)

So where does that leave us? Well, like I said at the top, there's no one definitive answer, but let's try to bucket some takeaways.

Good patterns:

* Let's start with an obvious one: reserve enough space for IDs. 64-bit `bigserial` or 128-bit `uuid` are both fine. 32-bit `serial`s are never worth it.

* Think about how insertions are going to affect indexes and WAL and aim to be reasonably performant. Any of `bigserial`, [sequential-uuids](https://github.com/tvondra/sequential-uuids), or [ulids](https://github.com/ulid/spec) are perfectly fine strategies.

* A downside of `bigserial` is that it locks you into only being able to generate IDs in one node of one database. Most people shouldn't be looking to scale out of their database too aggressively, but having the ability to generate IDs in a distributed way (like with UUIDs) might turn into a pretty important feature.

* IDs that are opaque from a user's perspective (i.e. not a sequence) are beneficial for security and business. They prevent iteration/collision attacks, and make it difficult to infer the quantities of data being generated.

These aren't slam dunks, but are probably good:

* I like the monotonic nature of formats like ULID. Having IDs that are always produced in a predictably ascending order is a nice feature for operator and end-user alike. As noted above, this has some potential for subtle database complications, but nothing overly worrying.

* ID prefixes like Stripe's `ch_`/`cus_`/`evt_`. This is a user-friendly feature in that it allows humans to easily distinguish resource type, and also unlocks the possibility of easily building some useful tooling.

Bad patterns:

* The only good case for V4 (random) UUIDs is that they have widespread support, but that's not a particularly strong argument. Potential performance downsides are considerable, and alternatives like smarter UUID generators or ULIDs are accessible and well-documented.

* As is usual good software advice, avoid inventing technology you don't have to. I'm currently dealing with an NIH ID generation format built to save a couple characters by encoding as base-32 instead of base-16. It's UUID storage compatible, but not UUID _query_ compatible, thus creating major cognitive and operational headaches for a very small gain.

### The exaltation of consultants (#exaltation-consultants)

In my first job out school we were somewhat of technological forerunners in that we'd adopted UUIDs (or as Microsoft calls them "GUIDs", because the fine distinction between "universal" and "global" is very important in the Enterprise™) as primary keys early and completely. No one there was a database guru, so there hadn't been a whole lot of rationale behind the original decision to use UUIDs, but it'd been made very early and we'd stuck to it consistently, so the convention was widespread.

After running into database performance issues, we hired a DBA contractor, who immediately and definitively identified our bottleneck as UUIDs (obviously!), and went to work (or more correctly, sent us to work) converting UUIDs to sequences.

At the time I didn't know anything about databases (or UUIDs for that matter), and was blasé towards this sort of dictate-from-on-high change request from a DBA, which was somewhat routine. This was a time when good open-source databases were not nearly as widespread, and corporate RDMSes like SQL Server and Oracle still held special mystique as magical black boxes, along the rare wizards with sufficient skill in the occult to peer inside of them. We made the changes, and spent hundreds of hours converting dozens of UUID keys to sequences.

In retrospect, I realize that although I knew nothing about databases at the time, neither did he. None of our performance problems were insert-related, and for a smart database engine, joining on a 64-bit key isn't functionally much different than joining on a high-entropy 128-bit one (again, see [SortSupport](/sortsupport)).

This is a long-winded way of saying that as long as they're used intelligently, UUIDs are absolutely _not_ as bad as many greybeard DBAs say they are. This common trope seems to be perpetuated by outdated information and insufficient understanding of database internals.

Personally, when I started research for this piece, I expected to come out having convinced myself that `bigserial` was the definitive right answer. That hasn't happened, and if anything, I've landed more in the camp of "intelligent" (i.e. performance aware) UUIDs.

## Bay walks (#bay-walks)

The photo at the top is from a Bay Area walk that I've been wanting to try for a long time, and _finally_ did last weekend. Start at the geographic center of San Francisco (Twin Peaks), make your way down through Golden Gate Park to the ocean, south along the Great Highway, onto the beach passed Fort Funston all the way down to Pacifica, then up into the hills and along Sweeney Ridge, until finally descending into San Bruno. Clocking in at a little over 42 km, it's almost exactly the length of one marathon, but when you're walking instead of running, you need the long summer daylight hours for time to make the trip.

<img src="/photographs/nanoglyphs/026-ids/san-bruno@2x.png" alt="Walk to San Bruno" class="wide" loading="lazy">

<img src="/photographs/nanoglyphs/026-ids/great-highway@2x.jpg" alt="Looking down the Great Highway" class="wide" loading="lazy">

<img src="/photographs/nanoglyphs/026-ids/pacifica-2@2x.jpg" alt="Pacifica" class="wide" loading="lazy">

<img src="/photographs/nanoglyphs/026-ids/sweeney-ridge@2x.jpg" alt="Sweeney Ridge" class="wide" loading="lazy">

<img src="/photographs/nanoglyphs/026-ids/south-san-francisco@2x.jpg" alt="South San Francisco" class="wide" loading="lazy">
